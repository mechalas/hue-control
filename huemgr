#! /usr/bin/python3

from huectl.bridge import HueBridge, HueBridgeSearch
from huectl.exception import BridgeDefined
from huectl.group import HueGroup
from huectl.scene import HueScene
from huectl.light import HueAlertEffect, HueDynamicEffect, HueLightStateChange
from huectl.color import HueColor, HueColorxyY, HueColorHSB, HueColorTemp, rgb_to_hsb, map_range
from argparse import ArgumentParser
import sys
import json
import asyncio
import ssdp
import socket
import urllib.request
import xml.etree.ElementTree as ET
import os.path
import configparser
import shutil

HueAppStandardScenes= (
	'Bright',
	'Concentrate',
	'Dimmed',
	'Energize',
	'Nightlight',
	'Read',
	'Relax'
)
HueEphemeralScenes= (
	'Last on state'
)

#---------------------------------------------------------------------------
# Config file class for storing Hue bridge configurations (userid's, 
# IP addresses/hostnames, serial numbers, and friendly names).
#
# We store user_ids the same way the Hue Bridge sends them to us
# when it auto-generates one: an ASCII-encoded hex string (essentially
# UUIDs).
#---------------------------------------------------------------------------

class Config:
	DefaultFilename= '~/.huemgr'

	def __init__(self, filename):
		if not filename:
			filename= Config.DefaultFilename

		self.filename= os.path.expanduser(filename)
		self.cf= configparser.ConfigParser()

		self.load()

	# Load/save
	#----------------------------------------

	def load(self):
		self.cf.read(self.filename)

	def save(self):
		# Make a backup first
		shutil.copyfile(self.filename, self.filename+'.bak')

		# Write new config
		with open(self.filename, 'w') as f:
			self.cf.write(f)

	# Bridge def management
	#----------------------------------------

	def add_bridge(self, name='', addr=None, serial=None, userid=None,
		overwrite=True):
		if addr is None:
			raise TypeError

		if serial is None:
			raise TypeError

		if userid is None:
			raise TypeError

		if not overwrite:
			check= self.find_bridge(name=name)
			if check is not None:
				raise BridgeExists(name=name)

			check= self.find_bridge(addr=addr)
			if check is not None:
				raise BridgeExists(name=name)

			check= self.find_bridge(serial=serial)
			if check is not None:
				raise BridgeExists(name=name)

		self.cf[serial]= {
			'name': name,
			'addr': addr,
			'user_id': userid
		}

		return True

	def _get_serial(self, name=None, addr=None):
		cf= self.cf

		if name:
			for serial in cf.sections():
				d= cf[serial]
				if 'name' in d:
					if name == d['name']:
						return serial
			return None

		if addr:
			for serial in cf.sections():
				d= cf[serial]
				if 'addr' in d:
					if addr == d['addr']:
						return serial
			return None

		return None

	
	def find_bridge(self, *args, name=None, addr=None, serial=None):
		cf= self.cf

		if len(args):
			# Search by serial number, then address, then name.
			search= args[0]

			bridge= self.find_bridge(serial=search)
			if bridge:
				return bridge

			bridge= self.find_bridge(addr=search)
			if bridge:
				return bridge

			bridge= self.find_bridge(name=search)
			if bridge:
				return bridge

		elif serial:
			return self.bridge(serial)

		elif name is not None:
			serial= self._get_serial(name=name)
			if serial:
				return self.bridge(serial)
			return None

		elif addr is not None:
			serial= self._get_serial(addr=addr)
			if serial:
				return self.bridge(serial)
			return None

		if 'DEFAULT' not in cf:
			return None

		if 'default_bridge' in cf['DEFAULT']:
			return self.bridge(cf['DEFAULT']['default_bridge'])

		return None

	def bridge(self, serial):
		if serial in self.cf:
			data= dict(self.cf[serial])
			data['serial_number']= serial
			return data

		return None

#----------------------------------------------------------------------------
# Bridge search
#----------------------------------------------------------------------------

def do_bridge_search(args):
	kwargs= dict()

	if args.search_time:
		kwargs['search_time']= args.search_time

	bridges= HueBridgeSearch.search(**kwargs)
	if bridges is not None:
		print(json.dumps(bridges, indent=4))
		exit(0)
	exit(1)

#----------------------------------------------------------------------------
# Groups
#----------------------------------------------------------------------------

def do_group_edit(args):
	hue= init_hue(args)

	groupid= args.groupid
	group= hue.get_group(args.groupid)

	if args.set_lights:
		group.set_lights_byid(args.set_lights)

	elif args.add_lights:
		group.add_lights_byid(args.add_lights)

	elif args.remove_lights:
		group.del_lights_byid(args.remove_lights)

def do_group_rename(args):
	hue= init_hue(args)

	group= hue.get_group(args.id)
	group.rename(args.name)

def do_group(args):
	hue= init_hue(args)

	groups= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_groups(raw=True))
			return

		lights= hue.get_all_lights()
		groups= hue.get_all_groups(lights=lights)

	else:
		for groupid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_group(groupid, raw=True))
			else:
				lights= hue.get_all_lights()
				group= hue.get_group(groupid, lights=lights)
				groups[groupid]= group

		if args.raw:
			return

	for group in groups.values():
		if group:
			print(group)
			for lightid in group.lights.keys(unresolved=True):
				light= group.lights.item(lightid)
				print('    '+str(light))
			print()

#----------------------------------------------------------------------------
# Lights
#----------------------------------------------------------------------------

def do_light_rename(args):
	hue= init_hue(args)

	light= hue.get_light(args.id)
	light.rename(args.name)

def do_light_set(args):
	hue= init_hue(args)

	lights= dict()
	kwargs= dict()

	if len(args.id):
		for lightid in args.id:
			light= hue.get_light(lightid)
			lights[lightid]= light
	elif args.all:
		lights= hue.get_all_lights()
	else:
		return

	if args.transition_time is not None:
		kwargs['ms']= args.transition_time

	# Create light state change object

	schange= HueLightStateChange()

	if args.brightness is not None:
		if _isinc(args.brightness):
			schange.inc_brightness(float(args.brightness))
		else:
			schange.set_brightness(float(args.brightness))

	if args.hue is not None:
		if _isinc(args.hue):
			schange.inc_hue(float(args.hue))
		else:
			schange.set_hue(float(args.hue))

	if args.saturation is not None:
		if _isinc(args.saturation):
			schange.inc_sat(float(args.saturation))
		else:
			schange.set_sat(float(args.saturation))

	if args.xy is not None:
		xy_pair= args.xy.split(',')
		if len(xy_pair) != 2:
			raise ValueError('x,y pair required')

		x, y= xy_pair

		if _isinc(x) or _isinc(y):
			schange.inc_xy((float(x),float(y)))
		else:
			schange.set_xy((float(x),float(y)))

	if args.color_temperature is not None:
		if _isinc(args.color_temperature):
			schange.inc_cct(int(args.color_temperature))
		else:
			schange.set_cct(int(args.color_temperature))

	if args.alert:
		schange.set_alert(args.alert)
	
	if args.dynamic_effect:
		schange.set_dynamic_effect(args.dynamic_effect)

	if args.transition_time is not None:
		schange.set_transition_time(args.transition_time)

	for light in lights.values():
		print(light.name)
		light.change_state(schange)

# Does the value start with "+" or "-"?

def _isinc(val):
	if val == 0:
		return False

	if val.startswith('+'):
		return True
	elif val.startswith('-'):
		return True

	return False

def do_light_power(args):
	hue= init_hue(args)

	lights= dict()
	kwargs= dict()

	if len(args.id):
		for lightid in args.id:
			light= hue.get_light(lightid)
			lights[lightid]= light
	elif args.all:
		lights= hue.get_all_lights()
	else:
		return

	schange= HueLightStateChange()

	if args.off:
		state=False
	else:
		state=True
		if args.brightness is not None:
			schange.set_brightness(args.brightness)

	schange.set_power(state)

	if args.transition_time is not None:
		schange.set_transition_time(args.transition_time)

	for light in lights.values():
		# Need to print more/better info here
		print(light.name)
		light.change_state(schange)

def do_light(args):
	hue= init_hue(args)
	
	lights= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_lights(raw=True))
			return

		lights= hue.get_all_lights()

	else:
		for lightid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_light(lightid, raw=True))
			else:
				light= hue.get_light(lightid)
				lights[lightid]= light

		if args.raw:
			return

	for light in lights.values():
		if light:
			print(light)

#----------------------------------------------------------------------------
# Rules
#----------------------------------------------------------------------------

def do_rule(args):
	hue= init_hue(args)
	rules= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_rules(raw=True))
			return

		rules= hue.get_all_rules()
	else:
		for ruleid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_rule(ruleid, raw=True))
			else:
				rule= hue.get_rule(ruleid)
				rules[ruleid]= rule

		if args.raw:
			return

	for rule in rules.values():
		print(rule)
		for condition in rule.conditions:
			print(f'   {condition}')
		print()

#----------------------------------------------------------------------------
# Scenes
#----------------------------------------------------------------------------

def do_scene(args):
	hue= init_hue(args)

	scenes= dict()

	# If we just want a raw response, no need to get light defs
	if not (args.raw or args.pretty):
		# If asked for a summary output, no need to get/resolve light
		# defs
		if args.summary:
			lights= dict()
		else:
			lights= hue.get_all_lights()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_scenes(raw=True))
			return

		if args.no_light_states or args.summary:
			scenes= hue.get_all_scenes(lights=lights)
		else:
			t_scenes= hue.get_all_scenes(lights=lights)
			for sceneid in t_scenes.keys():
				scenes[sceneid]= hue.get_scene(sceneid, lights=lights)

	else:
		for sceneid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_scene(sceneid, raw=True))
			else:
				scene= hue.get_scene(sceneid, lights=lights)

				scenes[sceneid]= scene

		if args.raw:
			return

	if args.sort:
		if args.sort == 'id':
			scenelist= map(lambda x: x[1], sorted(scenes.items()))
		else:
			scenelist= list(scenes.values())
			scenelist.sort(key=lambda x: getattr(x, args.sort))
	else:
		scenelist= scenes.values()

	for scene in scenelist:
		if args.ignore_autogenerated and (scene.name in HueAppStandardScenes or scene.name in HueEphemeralScenes):
			continue

		if scene:
			print(scene)
			if args.summary:
				continue

			for lightid in scene.lights.keys(unresolved=True):
				# We don't want the light's current state so we can't just
				# print the object as a str()

				light= scene.lights.item(lightid)
				if light:
					preset= ''
					if not args.no_light_states:
						# Get the light preset
						preset= _scene_preset(scene, lightid)
					print(f'    {lightid} {light.name}, {light.productname} {preset}')
				else:
					print(f'    {lightid} UNKNOWN LIGHT')
			print()

def _scene_preset(scene, lightid):
	preset= scene.preset(lightid)
	if not preset:
		return ''

	return str(preset)

# Use configparser to dump an INI file of the scene def. Use INI because
# it's easier for humans to read and write, and the Hue data structures
# are not very complicated.

def do_scene_dump(args):
	hue= init_hue(args)

	# Get light data so we can get names
	lights= hue.get_all_lights()
	scene= hue.get_scene(args.id)

	sdef= configparser.ConfigParser(interpolation=None, default_section='scene')
	sdef['scene']['id']= scene.id
	sdef['scene']['name']= scene.name
	if scene.transitiontime is not None:
		sdef['scene']['transitiontime']= str(scene.transitiontime)
	if hasattr(scene, 'group'):
		if scene.group is not None:
			sdef['scene']['group']= str(scene.group)
	if hasattr(scene, 'type'):
		if scene.type is not None:
			sdef['scene']['type']= scene.type
	if hasattr(scene, 'recycle'):
		sdef['scene']['recycle']= str(scene.recycle)

	# Do we have lightstates?
	if scene.has_presets():
		sdef['scene']['lightstates']= str(True)
	else:
		sdef['scene']['lightstates']= str(False)

	# Is there appdata?
	try:
		appdata= scene.application_data()
		if len(appdata):
			sdef['appdata']= appdata
	except:
		pass

	sdef.write(sys.stdout)

	for lightid in scene.lights.keys(unresolved=True):
		if lightid in lights:
			light= lights[lightid]
			lightname= light.name
		else:
			lightname= 'UNKNOWN LIGHT'

		# Get a new one of these each time because we want the
		# convenience of the write method and the ability to
		# print comments.

		sdef= configparser.ConfigParser(interpolation=None,
			default_section='scene')

		secname= 'light '+lightid
		preset= None

		if scene.has_presets():
			preset= scene.preset(lightid)
			sdef[secname]= preset.asdict()
			for k,v in sdef[secname].items():
				if k == 'hue':
					sdef[secname][k]= '{:.4f}'.format(map_range(float(v), HueColorHSB.range_hue, (0,360)))
				elif k == 'sat':
					sdef[secname][k]= '{:.4f}'.format(map_range(float(v), HueColorHSB.range_sat, (0,1)))
				elif k == 'bri':
					sdef[secname][k]= '{:.4f}'.format(map_range(float(v), HueColorHSB.range_bri, (0,1)))
		else:
			sdef[secname]= []

		# Add light name and color as comments
		print(f'; {lightname}')
		if preset:
			if preset.color() is not None:
				cname= preset.color().name()
				print(f'; color: {cname}')

		sdef.write(sys.stdout)
	
def do_scene_load(args):
	sdef= configparser.ConfigParser(interpolation=None)
	hue= init_hue(args)
	sceneid= None

	try:
		sdef.read_file(open(args.file))
	except Exception as e:
		print(f'{args.file}: {e}')
		exit(1)

	if args.scene_id:
		sceneid= args.scene_id
	else:
		if 'id' in sdef['scene']:
			sceneid= sdef['scene']['id']

	# Convert to a dictionary

	d= {
		'name': sdef['scene']['name'],
		'recycle': sdef['scene'].getboolean('recycle')
	}
	if 'group' in sdef['scene']:
		d['group']= sdef['scene']['group']
	if 'type' in sdef['scene']:
		d['type']= sdef['scene']['type']
	if 'transitiontime' in sdef['scene']:
		d['transitiontime']= sdef['scene'].getint('transitiontime')

	lightstates= dict()
	lightids= list()
	for sec in sdef.keys():
		if sec == 'scene':
			continue
		elif sec == 'appdata':
			if 'json' in sdef[sec]:
				d['appdata']= json.loads(sdef[sec]['json'])
		elif sec.startswith('light '):
			lightid= (sec.split(' '))[1]
			lightids.append(lightid)
			ls= dict()
			for k in sdef[sec].keys():
				if k == 'bri':
					v= round(map_range(sdef[sec].getfloat(k), (0,1), HueColor.range_bri))
				elif k == 'ct':
					v= sdef[sec].getint(k)
				elif k in ('x', 'y'):
					v= sdef[sec].getfloat(k)
					if 'xy' not in ls:
						ls['xy']= list()
					if k == 'x':
						ls['xy'].insert(0,v)
					else:
						ls['xy'].append(v)
					continue
				elif k == 'hue':
					v= round(map_range(sdef[sec].getfloat(k), (0,360), HueColorHSB.range_hue))
				elif k == 'sat':
					v= round(map_range(sdef[sec].getfloat(k), (0,1), HueColorHSB.range_sat))
				elif k == 'on':
					v= sdef[sec].getboolean(k)
				else:
					v= sdef[sec][k]
				ls[k]= v

			if len(ls):
				if 'xy' in ls:
					if len(ls['xy']) != 2:
						print(f'Incomplete xy color for light {lightid}')
						exit(1)
				lightstates[lightid]= ls

	if len(lightstates):
		d['lightstates']= lightstates
	if len(lightids):
		d['lights']= lightids

	scene= HueScene.parse_definition(d, bridge=hue, sceneid=sceneid)
	scene.save()

def do_scene_rename(args):
	hue= init_hue(args)

	scene= hue.get_scene(args.id)
	scene.rename(args.name)

def do_scene_del(args):
	hue= init_hue(args)

	for sceneid in args.id:
		try:
			hue.delete_scene(sceneid)
			print(f'Scene {sceneid} deleted')
		except Exception as e:
			print(e)

def do_scene_play(args):
	hue= init_hue(args)

	for sceneid in args.id:
		try:
			hue.recall_scene(sceneid)
			print(f'Playing scene {sceneid}')
		except Exception as e:
			print(e)

#----------------------------------------------------------------------------
# Schedules
#----------------------------------------------------------------------------

def do_schedule(args):
	hue= init_hue(args)

	scheds= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_schedules(raw=True))
			return

		scheds= hue.get_all_schedules()

	else:
		for schedid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_schedule(schedid, raw=True))
			else:
				sched= hue.get_schedule(schedid)
				scheds[schedid]= sched

		if args.raw:
			return

	for sched in scheds.values():
		print(sched)
		target= sched.command.target()
		print("    "+str(target))
		if isinstance(target, HueGroup):
			if 'scene' in sched.command.body:
				scene= hue.get_scene(sched.command.body['scene'])
				print("        "+str(scene))
		print()


#----------------------------------------------------------------------------
# Sensors
#----------------------------------------------------------------------------

def do_sensor(args):
	hue= init_hue(args)

	sensors= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_sensors(raw=True))
			return

		sensors= hue.get_all_sensors()

	else:
		for sensorid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_sensor(sensorid, raw=True))
			else:
				sensor= hue.get_sensor(sensorid)
				sensors[sensorid]= sensor

		if args.raw:
			return

	for sensor in sensors.values():
		print(sensor)

#----------------------------------------------------------------------------
# Resourcelinks
#----------------------------------------------------------------------------

def do_rlinks_get(args):
	hue= init_hue(args)

	rlinks= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_resourcelinks(raw=True))
			return

		rlinks= hue.get_all_resourcelinks()

	else:
		for rlinkid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_resourcelink(rlinkid, raw=True))
			else:
				rlink= hue.get_resourcelink(rlinkid)
				rlinks[rlinkid]= rlink

		if args.raw:
			return

	for rlink in rlinks.values():
		print(rlink)

#----------------------------------------------------------------------------
# Bridge Configuration
#----------------------------------------------------------------------------

def do_config_get(args):
	hue= init_hue(args)

	if args.all:
		raw_print(args, hue.get_datastore())
	elif args.raw or args.pretty:
		raw_print(args, hue.get_configuration(raw=True))
		return
	

def do_users_get(args):
	hue= init_hue(args)

	userlist= hue.userlist()
	for user in userlist.users():
		print(user)

def do_bridge_add(args):
	hue= None
	config= Config(args.config)

	user_id= None
	serial= None
	
	addr= args.address[0]
	if args.serial_number is not None:
		serial= args.serial_number

	if args.user_id is None:
		print(f'Registering a new user on bridge at {addr}.')

		if not args.button_pressed:
			input('Press the link button on the and hit <ENTER> to continue')

		hue= HueBridge(addr)
		try:
			user_id= hue.create_user()
		except Exception as e:
			print(e)
			print('User registration failed')
			exit(1)

		hue.set_user_id(user_id)
		hue.get_configuration()

		serial= hue.serial_number()
	else:
		user_id= args.user_id[0]

	if serial is None:
		hue= HueBridge(addr, user_id=user_id)
		serial= hue.serial_number()

	kwargs={
		'userid': user_id,
		'addr': addr,
		'serial': serial,
		'overwrite': True
	}

	if 'name' in args:
		# If the new name is rejected, print a warning but still
		# add our bridge definition to the config file (minus the
		# illegal name).

		try:
			hue.rename(args.name)
			kwargs['name']= args.name
		except Exception as e:
			print(e)

	elif hue is not None:
		name= hue.name

	if config.add_bridge(**kwargs):
		config.save()

#----------------------------------------------------------------------------
# Initialize API
#----------------------------------------------------------------------------

def init_hue(args):
	config= Config(args.config)

	bridge= config.find_bridge(args.bridge)
	if bridge is None:
		print('No bridge specified')
		exit(1)

	if 'user_id' in bridge:
		user_id= bridge['user_id']
	else:
		print('No user registered for bridge {:s} at {:s}'.format(
			bridge['serial_number'], bridge['addr']))
		exit(1)

	if 'addr' in bridge:
		addr= bridge['addr']
	else:
		print('TO DO: discover bridge IP address')
		exit(1)

	hue= HueBridge(addr, user_id=user_id)
	
	return hue

#----------------------------------------
# Color conversion
#----------------------------------------

def do_color(args):
	c= None

	if args.from_color == args.to_color:
		exit(0)

	if args.from_color != 'ct':
		if args.from_color == 'rgb' and ',' not in args.color:
			# Is it a hex color?
			try:
				c= hex_to_rgb(args.from_color)
			except:
				print('Color must be hex code or comma-separated triplet')
				exit(1)
		else:
			c= list(map(lambda x: float(x), args.color.split(',')))
			if len(c) != 3:
				print('Color must be comma-separated triplet')
				exit(1)

	if args.from_color == 'xyY':
		c[2]= map_range(c[2], (0,1), HueColorHSB.range_bri)
		color= HueColorxyY(*c)
	elif args.from_color == 'hsb':
		# Need to convert to bridge units
		c[0]= map_range(c[0], (0,360), HueColorHSB.range_hue)
		c[1]= map_range(c[1], (0,1), HueColorHSB.range_sat)
		c[2]= map_range(c[2], (0,1), HueColor.range_bri)
		color= HueColorHSB(*c)
	elif args.from_color == 'rgb':
		hsb= list(rgb_to_hsb(list(map(lambda x: x/255, c))))
		# Need to convert to bridge units
		hsb[0]= map_range(hsb[0], (0,360), HueColorHSB.range_hue)
		hsb[1]= map_range(hsb[1], (0,1), HueColorHSB.range_sat)
		hsb[2]= map_range(hsb[2], (0,1), HueColor.range_bri)
		color= HueColorHSB(*hsb)
		if args.to_color == 'hsb':
			print(color)
			exit(0)
	elif args.from_color == 'ct':
		color= HueColorTemp(float(args.color), kelvin=True)

	if args.to_color == 'xyY':
		newcolor= color.xyY()
		print("x={:.4f} y={:.4f} Y={:.4f}".format(newcolor.x(),
			newcolor.y(), newcolor.brightness()))
	elif args.to_color == 'hsb':
		newcolor= color.hsb()
		print('hue={:.4f} sat={:.4f} bri={:.4f}'.format(newcolor.hue(),
			newcolor.sat(), newcolor.brightness()))
	elif args.to_color == 'rgb':
		r, g, b= list(map(lambda x: int(x*255), color.rgb()))
		print(f'{r},{g},{b} #{r:02x}{b:02x}{g:02x}')


#----------------------------------------
# Util functions
#----------------------------------------

# Raw print and pretty-print

def raw_print(args, s):
	if args.pretty:
		print(json.dumps(json.loads(s), indent=4))
	else:
		print(s)

# Arguments that are common to a lot of commands

def standard_args(parser, *arglist):
	if 'bridge' in arglist:
		parser.add_argument('-b', '--bridge',
			help='Bridge to use. Can specify a serial number, friendly name, or address')

	if 'raw' in arglist:
		parser.add_argument('-r', '--raw', action='store_true',
			help='Print raw response')
	
	if 'pretty' in arglist:
		parser.add_argument('-R', '--pretty', action='store_true',
			help='Pretty-print raw response')


#===========================================================================
# Main program starts here
#===========================================================================

#----------------------------------------
# Command-line arguments
#----------------------------------------

parser= ArgumentParser()
parser.add_argument('-c', '--config', help='Use configuration file CONFIG',
	nargs=1)	

# Create subcommands

subparsers= parser.add_subparsers()

# Bridge management 
#--------------------

# bridge-search

parser_search= subparsers.add_parser('bridge-search',
	help='Search for a Philips Hue bridge on local networks')
parser_search.add_argument('-S', '--search-time', type=int,
	help='The time to spend searching for Hue Bridges in seconds')
parser_search.set_defaults(func=do_bridge_search)

# bridge-add

parser_bridge_add= subparsers.add_parser('bridge-add',
	help='Add a bridge definition')
parser_bridge_add.add_argument('-B', '--button-pressed', action='store_true',
	help='The link button on the bridge has been pressed.')
parser_bridge_add.add_argument('-n', '--name', nargs='?',
	help='A friendly name for the bridge')
parser_bridge_add.add_argument('-u', '--user-id', nargs=1,
	help='The user id for the target bridge. If ommitted, a new user will be registered on the bridge.')
parser_bridge_add.add_argument('-s', '--serial-number', nargs='?',
	help='The bridge serial number. Required if the bridge is not online.')
parser_bridge_add.add_argument('address', nargs=1, 
	help='The IP address of the bridge to add')
parser_bridge_add.set_defaults(func=do_bridge_add)

# Group management
#--------------------

# list

parser_group= subparsers.add_parser('group',
	help='List group definitions')
standard_args(parser_group, 'raw', 'pretty', 'bridge')
parser_group.add_argument('id', nargs='*', help='Group IDs')
parser_group.set_defaults(func=do_group)

# rename

parser_group_rename= subparsers.add_parser('group-rename',
	help='Rename a group')
standard_args(parser_group_rename, 'bridge')
parser_group_rename.add_argument('id', help='Group ID')
parser_group_rename.add_argument('name', help='New group name')
parser_group_rename.set_defaults(func=do_group_rename)

# light memembership mgmt

parser_group_edit= subparsers.add_parser('group-lights',
	help="Set/change a group's member lights")
standard_args(parser_group_edit, 'bridge')
parser_group_edit.add_argument('-g', '--groupid', help='The group to modify')
parser_group_edit.add_argument('-a', '--add-lights', nargs='+',
	metavar='LIGHTID', help='Add lights to the group')
parser_group_edit.add_argument('-r', '--remove-lights', nargs='+',
	metavar='LIGHTID', help='Remove lights from the group')
parser_group_edit.add_argument('-s', '--set-lights', nargs='+',
	metavar='LIGHTID', help='Set the list of lights in the group. Cannot be combined with -a or -r.')
parser_group_edit.set_defaults(func=do_group_edit)

# Light management
#--------------------

# light listing

parser_light= subparsers.add_parser('light',
	help='List light definitions')
standard_args(parser_light, 'raw', 'pretty', 'bridge')
parser_light.add_argument('id', nargs='*', help='Light IDs')
parser_light.set_defaults(func=do_light)

# light on/off

parser_light_pwr= subparsers.add_parser('light-power',
	help='Turn lights on (default) or off')
standard_args(parser_light_pwr, 'bridge')
parser_light_pwr.add_argument('-a', '--all',
	help='Control all lights on the bridge.')
parser_light_pwr.add_argument('-t', '--transition-time', type=int,
	help='Set transition time in 100ms (e.g. 5=500ms)')
group_ex= parser_light_pwr.add_mutually_exclusive_group()
group_ex.add_argument('-B', '--brightness', nargs='?', type=float, 
	help='Turn lights on to the given brightness level.')
group_ex.add_argument('-X', '--off', action='store_true',
	help='Turn lights off instead of on')
parser_light_pwr.add_argument('id', nargs='*', help='Light IDs')
parser_light_pwr.set_defaults(func=do_light_power)

# light rename

parser_light_rename= subparsers.add_parser('light-rename', 
	help='Rename a light')
standard_args(parser_light_rename, 'bridge')
parser_light_rename.add_argument('id', help='Light ID')
parser_light_rename.add_argument('name', help='New light name')
parser_light_rename.set_defaults(func=do_light_rename)

# set light state

parser_light_set= subparsers.add_parser('light-set',
	help='Set light attributes')
standard_args(parser_light_set, 'bridge')
parser_light_set.add_argument('-a', '--all', action='store_true',
	help='Set all lights on the bridge')

parser_light_set.add_argument('-c', '--color-temperature', type=str,
	help='Set a light color temperature in Kelvin, or specify a +/- increment.')
parser_light_set.add_argument('--xy', type=str,
	help='Set xy color coordinates as a comma-separated pair, or specify a +/- increment. Cannot be combined with other color modes.')
parser_light_set.add_argument('-H', '--hue', type=str,
	help='Set a color hue, or specify a +/- increment. Hue can be fractional. Cannot be combined with other color modes.')
parser_light_set.add_argument('-S', '--saturation', type=str,
	help='Set a color hue, or specify a +/- increment. Cannot be combined with other color modes.')

parser_light_set.add_argument('-B', '--brightness', type=str,
	help='Set a brightness, or specify a +/- increment.')

parser_light_set.add_argument('-A', '--alert', choices=(HueAlertEffect.NoAlert,
		HueAlertEffect.Select, HueAlertEffect.LSelect),
	help='Set an alert effect')
parser_light_set.add_argument('-e', '--dynamic-effect',
	choices=(HueDynamicEffect.NoEffect, HueDynamicEffect.ColorLoop),
	help='Set a dynamic effect')

parser_light_set.add_argument('-t', '--transition-time', type=int,
	help='Set transition time in 100ms (e.g. 5=500ms)')

parser_light_set.add_argument('id', nargs='*', help='Light IDs')
parser_light_set.set_defaults(func=do_light_set)

# Rule management
#--------------------

# rule

parser_rule= subparsers.add_parser('rule',
	help='List rule definitions')
standard_args(parser_rule, 'raw', 'pretty', 'bridge')
parser_rule.add_argument('id', nargs='*', help='Scene IDs')
parser_rule.set_defaults(func=do_rule)

# Scene management
#--------------------

# scene

parser_scene= subparsers.add_parser('scene',
	help='List scene definitions')
standard_args(parser_scene, 'raw', 'pretty', 'bridge')
parser_scene.add_argument('-i', '--ignore-autogenerated', action='store_true',
	help="""Filter out the Hue app's auto-generated scenes from the scene list. These include the "standard" Hue app scenes ("""+', '.join(HueAppStandardScenes)+""") that it auto-creates for each room, as well as the "Last on state" scenes used by dimmer switches. This may accidentally filter out scenes created by the user if they use a name that matches one of the standard scenes.""")
parser_scene.add_argument('-x', '--no-light-states', action='store_true',
	help="Don't display light states")
parser_scene.add_argument('-S', '--summary', action='store_true',
	help='Only print a brief scene summary')
parser_scene.add_argument('-s', '--sort', choices=['name','id','lastupdated'],
	help='Sort list by field')
parser_scene.add_argument('id', nargs='*', help='Scene IDs')
parser_scene.set_defaults(func=do_scene)

# scene-play

parser_scene_play= subparsers.add_parser('scene-play',
	help='Play a scene')
standard_args(parser_scene_play, 'bridge')
parser_scene_play.add_argument('id', nargs='+', help='Scene IDs')
parser_scene_play.set_defaults(func=do_scene_play)

# scene-rename

parser_scene_rename= subparsers.add_parser('scene-rename', 
	help='Rename a scene')
standard_args(parser_scene_rename, 'bridge')
parser_scene_rename.add_argument('id', help='Light ID')
parser_scene_rename.add_argument('name', help='New scene name')
parser_scene_rename.set_defaults(func=do_scene_rename)

# scene-delete

parser_scene_del= subparsers.add_parser('scene-delete',
	help='Delete a scene')
standard_args(parser_scene_del, 'bridge')
parser_scene_del.add_argument('id', nargs='+', help='Scene IDs')
parser_scene_del.set_defaults(func=do_scene_del)

# scene-dump

parser_scene_dump= subparsers.add_parser('scene-dump',
	help='Dump a scene definition to INI format')
standard_args(parser_scene_dump, 'bridge')
parser_scene_dump.add_argument('id', help='Scene ID')
parser_scene_dump.set_defaults(func=do_scene_dump)

# scene-load

parser_scene_load= subparsers.add_parser('scene-load',
	help='Load a scene definition from an INI file and save it to the bridge. A new scene will be created unless an existing scene id is specified.')
standard_args(parser_scene_load, 'bridge')
parser_scene_load.add_argument('-s', '--scene-id', 
	help='Update scene with scene id SCENE_ID. This will override any scene id stored in the INI file.')
parser_scene_load.add_argument('file', 
	help='The INI file containing the scene definition')
parser_scene_load.set_defaults(func=do_scene_load)

# Schedule management
#--------------------

# schedule

parser_sched= subparsers.add_parser('schedule',
	help='List schedule definitions')
standard_args(parser_sched, 'raw', 'pretty', 'bridge')
parser_sched.add_argument('id', nargs='*', help='Schedule IDs')
parser_sched.set_defaults(func=do_schedule)

# Sensor management
#--------------------

parser_sensor= subparsers.add_parser('sensor',
	help='List sensor definitions')
standard_args(parser_sensor, 'raw', 'pretty', 'bridge')
parser_sensor.add_argument('id', nargs='*', help='Sensor IDs')
parser_sensor.set_defaults(func=do_sensor)

# Bridge configuration
#--------------------

parser_config_get= subparsers.add_parser('config-get',
	help='Get bridge configuration')
standard_args(parser_config_get, 'raw', 'pretty', 'bridge')
parser_config_get.add_argument('-a', '--all', action='store_true',
	help='Dump the full datastore (implies --raw).')
parser_config_get.set_defaults(func=do_config_get)

# Bridge whitelist management
#--------------------

parser_userlist_get= subparsers.add_parser('user-get',
	help='Get authorized userlist')
standard_args(parser_userlist_get, 'bridge')
parser_userlist_get.set_defaults(func=do_users_get)

# Resourcelinks
#----------------------------------------

parser_rlink_get= subparsers.add_parser('rlinks',
	help='Get resourcelinks')
standard_args(parser_rlink_get, 'raw', 'pretty', 'bridge')
parser_rlink_get.add_argument('id', nargs='*', help='Resourcelink IDs')
parser_rlink_get.set_defaults(func=do_rlinks_get)


# Color conversion
#----------------------------------------

parser_color= subparsers.add_parser('color', 
	help='Convert colors between Hue-supported color systems')
parser_color.add_argument('-f', '--from-color', choices=['xyY','hsb','rgb','ct'],
	required=True, help='System to convert from')
parser_color.add_argument('-t', '--to-color', choices=['xyY','hsb','rgb'],
	required=True, help='System to convert to')
parser_color.add_argument('color', help='A color coordinate as comma-separated values. xyY are from 0 to 1, h is from 0 to 360, sat and bri are from 0 to 1, rgb are from 0 to 255, and ct is a color temperature in Kelvin.')
parser_color.set_defaults(func=do_color)

#----------------------------------------
# Parse and go
#----------------------------------------

args= parser.parse_args()

if 'func' in args:
	args.func(args)


