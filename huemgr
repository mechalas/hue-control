#! /usr/bin/python3

from huectl.bridge import HueBridge, HueBridgeSearch, HueDeviceScanResults
from huectl.group import HueGroup, HueGroupType, HueRoom
from huectl.scene import HueScene, HueSceneType
from huectl.light import HueAlertEffect, HueDynamicEffect, HueLightStateChange, HueColorMode
from huectl.color import HueColor, HueColorxyY, HueColorHSB, HueColorTemp, rgb_to_hsb, map_range
import huectl.colorwheel as colorwheel
from argparse import ArgumentParser
import textwrap
import sys
import json
import asyncio
import ssdp
import socket
import urllib.request
import xml.etree.ElementTree as ET
import os.path
import configparser
import shutil
import time

HueAppStandardScenes= (
	'Bright',
	'Concentrate',
	'Dimmed',
	'Energize',
	'Nightlight',
	'Read',
	'Relax'
)
HueEphemeralScenes= (
	'Last on state'
)

#---------------------------------------------------------------------------
# Config file class for storing Hue bridge configurations (userid's, 
# IP addresses/hostnames, serial numbers, and friendly names).
#
# We store user_ids the same way the Hue Bridge sends them to us
# when it auto-generates one: an ASCII-encoded hex string (essentially
# UUIDs).
#---------------------------------------------------------------------------

class Config:
	DefaultFilename= '~/.huemgr'

	def __init__(self, filename):
		if not filename:
			filename= Config.DefaultFilename

		self.filename= os.path.expanduser(filename)
		self.cf= configparser.ConfigParser()

		self.load()

	# Load/save
	#----------------------------------------

	def load(self):
		self.cf.read(self.filename)

	def save(self):
		# Make a backup first
		if os.path.exists(self.filename):
			shutil.copyfile(self.filename, self.filename+'.bak')

		# Write new config
		with open(self.filename, 'w') as f:
			self.cf.write(f)

	# Bridge def management
	#----------------------------------------

	def add_bridge(self, name='', addr=None, serial=None, userid=None,
		overwrite=True):
		if addr is None:
			raise TypeError

		if serial is None:
			raise TypeError

		if userid is None:
			raise TypeError

		if not overwrite:
			check= self.get_bridge(name=name)
			if check is not None:
				raise BridgeExists(name=name)

			check= self.get_bridge(addr=addr)
			if check is not None:
				raise BridgeExists(name=name)

			check= self.get_bridge(serial=serial)
			if check is not None:
				raise BridgeExists(name=name)

		self.cf[serial]= {
			'addr': addr,
			'user_id': userid
		}

		if len(name):
			self.cf[serial]['name']= name

		# If we don't already have a default bridge, make it this one

		if 'DEFAULT' not in self.cf:
			self.cf['DEFAULT']= {
				'default_bridge': serial
			}
			return True

		default= self.cf['DEFAULT']
		if 'default_bridge' not in default:
			default['default_bridge']= serial

		return True

	def set_default_bridge(self, serial):
		if 'DEFAULT' not in self.cf:
			self.cf['DEFAULT']= {
				'default_bridge': serial
			}
		else:
			self.cf['DEFAULT']['default_bridge']= serial

	def _get_serial(self, name=None, addr=None):
		cf= self.cf

		if name:
			for serial in cf.sections():
				d= cf[serial]
				if 'name' in d:
					if name.lower() == d['name'].lower():
						return serial
			return None

		if addr:
			for serial in cf.sections():
				d= cf[serial]
				if 'addr' in d:
					if addr == d['addr']:
						return serial
			return None

		return None

	
	def get_bridge(self, *args, name=None, addr=None, serial=None):
		cf= self.cf

		if len(args):
			# Search by serial number, then address, then name.
			search= args[0]

			bridge= self.get_bridge(serial=search)
			if bridge:
				return bridge

			bridge= self.get_bridge(addr=search)
			if bridge:
				return bridge

			bridge= self.get_bridge(name=search)
			if bridge:
				return bridge

			return None

		elif serial:
			return self.bridge(serial)

		elif name is not None:
			serial= self._get_serial(name=name)
			if serial:
				return self.bridge(serial)
			return None

		elif addr is not None:
			serial= self._get_serial(addr=addr)
			if serial:
				return self.bridge(serial)
			return None

		if 'DEFAULT' not in cf:
			return None

		if 'default_bridge' in cf['DEFAULT']:
			return self.bridge(cf['DEFAULT']['default_bridge'])

		return None

	def bridge(self, serial):
		if serial in self.cf:
			data= dict(self.cf[serial])
			data['serial_number']= serial
			return data

		return None

	def update(self, serial, addr=None, name=None):
		save= False

		if serial not in self.cf:
			return False

		cf= self.cf[serial]
		if addr:
			if cf['addr'] != addr:
				cf['addr']= addr
				save= True

		if name:
			if cf['name'] != name:
				cf['name']= name
				save= True

		if save:
			self.save()
			return True	

		return False

#----------------------------------------------------------------------------
# Bridge search
#----------------------------------------------------------------------------

def do_bridge_search(args):
	kwargs= dict()

	if args.quick:
		bridges= HueBridgeSearch.quick_search()
	else:
		if args.search_time:
			kwargs['search_time']= args.search_time

		bridges= HueBridgeSearch.search(**kwargs)

	if bridges is not None:
		for serial,data in bridges.items():
			addr= data['ipAddress']
			s= f"Serial number {serial} at {addr}"
			if 'name' in data:
				s+= " ("+data['name']+")"
			print(s)
		exit(0)

	exit(1)

#----------------------------------------------------------------------------
# Groups
#----------------------------------------------------------------------------

def do_room_classes(args):
	rclasses= HueRoom.supported_byver()
	verlist= sorted(rclasses.keys())

	for ver in verlist:
		print(f'Room Classes in API version {ver}:')
		for rc in sorted(rclasses[ver]):
			print(f'   {rc}')

def do_group_del(args):
	hue= init_hue(args)

	for groupid in args.id:
		try:
			hue.delete_group(groupid)
			print(f'Deleted group {groupid}')
		except Exception as e:
			print(str(e))
			print(f'Could not delete group {groupid}')

def do_group_add(args):
	hue= init_hue(args)

	# Get our lights
	lights= hue.get_all_lights()

	group= HueGroup(hue)
	group.rename(args.name)

	if args.type:
		group.set_type(args.type)

		if args.type == HueGroupType.Room and args.room_class is not None:
			group.set_room_class(args.room_class)

	try:
		group.save()
	except Exception as e:
		print(str(e))
		print('Could not add group')
		exit(1)
	
	print('Created group {args.nane} with id {groupid}')

def do_group_edit(args):
	hue= init_hue(args)

	groupid= args.groupid
	group= hue.get_group(args.groupid)

	if args.set_lights:
		group.set_lights_byid(args.set_lights)

	elif args.add_lights:
		group.add_lights_byid(args.add_lights)

	elif args.remove_lights:
		group.del_lights_byid(args.remove_lights)

def do_group_rename(args):
	hue= init_hue(args)

	group= hue.get_group(args.id)
	group.rename(args.name)

def do_group(args):
	hue= init_hue(args)

	groups= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_groups(raw=True))
			return

		lights= hue.get_all_lights()
		groups= hue.get_all_groups(lights=lights)

	else:
		for groupid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_group(groupid, raw=True))
			else:
				lights= hue.get_all_lights()
				group= hue.get_group(groupid, lights=lights)
				groups[groupid]= group

		if args.raw or args.pretty:
			return

	if args.sort:
		if args.sort == 'id':
			grouplist= map(lambda x: x[1], sorted(groups.items()))
		else:
			grouplist= list(groups.values())
			grouplist.sort(key=lambda x: getattr(x, args.sort))
	else:
		grouplist= groups.values()

	maxw= len(max(groups.keys(), key=len))
	fmt= '{:'+str(maxw)+'s} {:s}'

	for group in grouplist:
		if group:
			s= fmt.format(group.id, group.name)

			if group.type is not None:
				if group.type == HueGroupType.Room:
					s+= f' ({group.type} [{group.room_class}])'
				else:
					s+= f' ({group.type})'

			print(s)

			for lightid in group.lights.keys(unresolved=True):
				light= group.lights.item(lightid)
				lstate= _light_state(light.lightstate)
				print(f'    {light.id} {light.name}, {lstate}')
			print()

#----------------------------------------------------------------------------
# Lights
#----------------------------------------------------------------------------

def do_light_add(args):
	hue= init_hue(args)
	serials= list()

	if 'serialnum' in args:
		if len(args.serialnum) > 10:
			print("Can't search for more than 10 serial numbers at once")
			exit(1)
		serials= args.serialnum

	if args.no_scan:
		scan= HueDeviceScanResults(hue)
	else:
		try:
			scan= hue.init_light_search(serials)
			print(f'Searching for new lights')
		except Exception as e:
			print(str(e))
			print('Search failed')
			exit(1)

	# Report light status every 3 seconds. The number 3 is chosen
	# arbitrarily.

	repeat= True
	found= set()
	while repeat:
		hue.get_new_lights(scan)

		for lightid, name in scan.found.items():
			newline= False
			if lightid not in found:
				if not newline and not args.no_scan:
					print()
					newline= True

				found+= lightid
				print(f'{lightid} {name}')

		if scan.scan_active():
			time.sleep(3)
		else:
			repeat= False

		if not args.no_scan:
			print('.', end='')
			sys.stdout.flush()

	if not args.no_scan:
		print()

	print('Found {:d} new lights'.format(len(found)))
	exit(0)

def do_light_rename(args):
	hue= init_hue(args)

	light= hue.get_light(args.id)
	light.rename(args.name)

def do_light_set(args):
	hue= init_hue(args)

	lights= dict()
	kwargs= dict()

	if len(args.id):
		for lightid in args.id:
			light= hue.get_light(lightid)
			lights[lightid]= light
	elif args.all:
		lights= hue.get_all_lights()
	else:
		return

	if args.transition_time is not None:
		kwargs['ms']= round(args.transition_time*10)

	# Create light state change object

	schange= HueLightStateChange()

	if args.color_name is not None:
		try:
			h, s, b= colorwheel.colordef(args.color_name)
		except ValueError as e:
			print(str(e))
			exit(1)
		schange.set_hue(h)
		schange.set_sat(s)
		schange.set_brightness(b)
	else:
		if args.brightness is not None:
			if _isinc(args.brightness):
				schange.inc_brightness(float(args.brightness))
			else:
				schange.set_brightness(float(args.brightness))

		if args.hue is not None:
			if _isinc(args.hue):
				schange.inc_hue(float(args.hue))
			else:
				schange.set_hue(float(args.hue))

		if args.saturation is not None:
			if _isinc(args.saturation):
				schange.inc_sat(float(args.saturation))
			else:
				schange.set_sat(float(args.saturation))

		if args.xy is not None:
			xy_pair= args.xy.split(',')
			if len(xy_pair) != 2:
				raise ValueError('x,y pair required')

			x, y= xy_pair

			if _isinc(x) or _isinc(y):
				schange.inc_xy((float(x),float(y)))
			else:
				schange.set_xy((float(x),float(y)))

		if args.color_temperature is not None:
			if _isinc(args.color_temperature):
				schange.inc_cct(int(args.color_temperature))
			else:
				schange.set_cct(int(args.color_temperature))

	if args.alert:
		schange.set_alert(args.alert)
	
	if args.dynamic_effect:
		schange.set_dynamic_effect(args.dynamic_effect)

	if args.transition_time is not None:
		schange.set_transition_time(round(args.transition_time*10))

	for light in lights.values():
		print(light.name)
		light.change_state(schange)

# Does the value start with "+" or "-"?

def _isinc(val):
	if val == 0:
		return False

	if val.startswith('+'):
		return True
	elif val.startswith('-'):
		return True

	return False

def do_light_power(args):
	hue= init_hue(args)

	lights= dict()
	kwargs= dict()

	if len(args.id):
		for lightid in args.id:
			light= hue.get_light(lightid)
			lights[lightid]= light
	elif args.all:
		lights= hue.get_all_lights()
	else:
		return

	schange= HueLightStateChange()

	if args.off:
		state=False
	else:
		state=True
		if args.brightness is not None:
			schange.set_brightness(args.brightness)

	schange.set_power(state)

	if args.transition_time is not None:
		schange.set_transition_time(round(args.transition_time*10))

	for light in lights.values():
		# Need to print more/better info here
		print(light.name)
		light.change_state(schange)

def do_light(args):
	hue= init_hue(args)
	
	lights= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_lights(raw=True))
			return

		lights= hue.get_all_lights()

	else:
		for lightid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_light(lightid, raw=True))
			else:
				light= hue.get_light(lightid)
				lights[lightid]= light

		if args.raw or args.pretty:
			return

	if args.sort:
		if args.sort == 'id':
			lightlist= map(lambda x: x[1], sorted(lights.items()))
		else:
			lightlist= list(lights.values())
			lightlist.sort(key=lambda x: getattr(x, args.sort))
	else:
		lightlist= lights.values()

	maxw= len(max(lights.keys(), key=len))
	fmt= '{:'+str(maxw)+'s} {:s} ({:s}) {:s}'
	for light in lightlist:
		if light:
			state= light.lightstate
			statedef= _light_state(state)
			if args.on:
				if not state.reachable or not state.on:
					continue
			elif args.off:
				if not state.reachable or state.on:
					continue

			print(fmt.format(light.id, light.name, light.productname, statedef))

#----------------------------------------------------------------------------
# Rules
#----------------------------------------------------------------------------

def do_rule(args):
	hue= init_hue(args)
	rules= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_rules(raw=True))
			return

		rules= hue.get_all_rules()
	else:
		for ruleid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_rule(ruleid, raw=True))
			else:
				rule= hue.get_rule(ruleid)
				rules[ruleid]= rule

		if args.raw:
			return

	for rule in rules.values():
		print(rule)
		for condition in rule.conditions:
			print(f'   {condition}')
		print()

#----------------------------------------------------------------------------
# Scenes
#----------------------------------------------------------------------------

# Print out a scene list, either a summary or with full light state 
# information. The latter takes longer, as we have to look up our
# lights. Otherwise, we just need groups in case there are group
# scenes.

def do_scene(args):
	hue= init_hue(args)

	if args.summary and args.no_light_states:
		print('Cannot combine --summary with --no-light-states')
		exit(1)

	groups= dict()
	scenes= dict()

	# If we just want a raw response, no need to get light or group defs
	if not (args.raw or args.pretty):
		# If asked for a summary output, no need to get/resolve light
		# defs
		if args.summary:
			lights= dict()
		else:
			print('Loading lights...')
			lights= hue.get_all_lights()

		print('Loading groups...')
		groups= hue.get_all_groups()


	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_scenes(raw=True))
			return

		print('Loading scene index...')
		if args.no_light_states or args.summary:
			scenes= hue.get_all_scenes(lights=lights)
		else:
			t_scenes= hue.get_all_scenes(lights=lights)
			print('Loading scenes...')
			for sceneid in t_scenes.keys():
				scenes[sceneid]= hue.get_scene(sceneid, lights=lights)

	else:
		for sceneid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_scene(sceneid, raw=True))
			else:
				scene= hue.get_scene(sceneid, lights=lights)

				scenes[sceneid]= scene

		if args.raw or args.pretty:
			return

	if args.sort:
		if args.sort == 'id':
			scenelist= map(lambda x: x[1], sorted(scenes.items()))
		else:
			scenelist= list(scenes.values())
			scenelist.sort(key=lambda x: getattr(x, args.sort))
	else:
		scenelist= scenes.values()

	maxw= len(max(scenes.keys(), key=len))
	fmt= '{:'+str(maxw)+'s}'

	for scene in scenelist:
		if args.ignore_autogenerated and (scene.name in HueAppStandardScenes or scene.name in HueEphemeralScenes):
			continue

		if scene:
			lightlist= scene.lights.keys(unresolved=True)

			sceneinfo= fmt.format(scene.id)

			if scene.type == HueSceneType.GroupScene:
				group= groups[scene.group]
				sceneinfo+= f' {scene.name} ({scene.type}: {group.name})'
			else:
				sceneinfo+= f' {scene.name} ({scene.type})'

			if scene.locked:
				sceneinfo+= ' LOCKED'

			if args.summary:
				if len(lightlist):
					sceneinfo+= ' Lights {:s}'.format(','.join(lightlist))

			print(sceneinfo)

			if args.summary:
				continue

			for lightid in lightlist:
				# We don't want the light's current state so we can't just
				# print the object as a str()

				light= scene.lights.item(lightid)
				if light:
					preset= ''
					if not args.no_light_states:
						# Get the light preset
						preset= _scene_preset(scene, lightid)
					print(f'    {lightid} {light.name} ({light.productname}) {preset}')
				else:
					print(f'    {lightid} UNKNOWN LIGHT')
			print()

def _scene_preset(scene, lightid):
	preset= scene.preset(lightid)
	if not preset:
		return ''

	return _light_state(preset)

def _light_state(state):
	# Turn the state in to a printed string

	if hasattr(state, 'reachable'):
		if state.reachable == False:
			return '(unreachable)'
	if state.on:
		pdef= 'On'
	else:
		return 'Off'

	# It's not a dimmable light

	if state.colormode is None:
		return pdef

	pdef+= ' {:d}%'.format(round(state.brightness(torange=(0,100))))

	if state.colormode == HueColorMode.CT:
		pdef+= ' at {:d}K'.format(state.kelvin())
		return pdef

	color= state.color()

	if state.colormode == HueColorMode.HSB:
		hue= color.hue(torange=(0,360))
		sat= color.sat(torange=(0,100))
		pdef+= ', Hue {:d}, Sat {:d}% '.format(round(hue), round(sat))
	elif state.colormode == HueColorMode.xyY:
		pdef+= ', xy {:.4f},{:.4f} '.format(color.x(), color.y())
	else:
		return pdef

	pdef+= '('+color.name()+')'

	return pdef

# Use configparser to dump an INI file of the scene def. Use INI because
# it's easier for humans to read and write, and the Hue data structures
# are not very complicated.

def do_scene_dump(args):
	hue= init_hue(args)

	# Get light data so we can get names
	lights= hue.get_all_lights()
	scene= hue.get_scene(args.id)

	sdef= configparser.ConfigParser(interpolation=None, default_section='scene')
	sdef['readonly']= {}
	sdef['scene']['name']= scene.name
	if scene.transitiontime is not None:
		sdef['scene']['transitiontime']= str(scene.transitiontime)

	if hasattr(scene, 'group'):
		if scene.group is not None:
			sdef['readonly']['group']= str(scene.group)
	if hasattr(scene, 'type'):
		if scene.type is not None:
			sdef['readonly']['type']= scene.type
	if hasattr(scene, 'recycle'):
		sdef['readonly']['recycle']= str(scene.recycle)

	# Do we have lightstates?
	if not scene.has_presets():
		sdef['readonly']['lightstates']= str(False)

	# Is there appdata?
	try:
		appdata= scene.application_data()
		if len(appdata):
			sdef['appdata']['version']= appdata['version']
			sdef['appdata']['data']= appdata['data']
	except:
		pass

	# Get our destination filehandle
	if args.file is not None:
		fh= open(args.file, 'w')
	else:
		fh= sys.stdout

	sdef.write(fh)

	for lightid in scene.lights.keys(unresolved=True):
		if lightid in lights:
			light= lights[lightid]
			lightname= light.name
		else:
			lightname= 'UNKNOWN LIGHT'

		# Get a new one of these each time because we want the
		# convenience of the write method and the ability to
		# print comments.

		sdef= configparser.ConfigParser(interpolation=None,
			default_section='scene')

		secname= 'light '+lightid
		preset= None

		if scene.has_presets():
			preset= scene.preset(lightid)
			dpreset= preset.asdict()
			sdef[secname]= dpreset
			for k,v in sdef[secname].items():
				if k == 'hue':
					sdef[secname][k]= '{:.4f}'.format(map_range(float(v), HueColorHSB.range_hue, (0,360)))
				elif k == 'sat':
					sdef[secname][k]= '{:.4f}'.format(map_range(float(v), HueColorHSB.range_sat, (0,1)))
				elif k == 'bri':
					sdef[secname][k]= '{:.4f}'.format(map_range(float(v), HueColorHSB.range_bri, (0,1)))
				elif k == 'xy':
					# The configparser module doesn't deal with lists
					sdef[secname]['x']= str(dpreset['xy'][0])
					sdef[secname]['y']= str(dpreset['xy'][1])

			# We separate this into x and y
			if 'xy' in dpreset:
				del sdef[secname]['xy']

		else:
			sdef[secname]= {}

		# Add light name and color as comments
		print(f'; {lightname}', file=fh)
		if preset:
			if preset.color() is not None:
				cname= preset.color().name()
				print(f'; color: {cname}', file=fh)

		sdef.write(fh)

	if args.file is not None:
		print(f'Scene definition for {scene.name} saved to {args.file}')
	
def do_scene_load(args):
	sdef= configparser.ConfigParser(interpolation=None)
	hue= init_hue(args)
	sceneid= None
	errors= False
	newscene= True

	try:
		sdef.read_file(open(args.file))
	except Exception as e:
		print(f'{args.file}: {e}')
		exit(1)

	if 'scene' not in sdef:
		print("[scene] section is required")
		exit(1)

	if args.scene_id:
		sceneid= args.scene_id
		newscene= False

	# Convert to a dictionary

	d= dict()

	if 'name' in sdef['scene']:
		d['name']= sdef['scene']['name']

	if 'recycle' in sdef['scene']:
		if not newscene:
			print("Can't change recycle parameter of an existing scene")
			errors= True
		else:
			d['recycle']= sdef['scene'].getboolean('recycle')

	if 'group' in sdef['scene']:
		if not newscene:
			print("Can't change the group of an existing scene")
			errors= True
		else:
			d['group']= sdef['scene']['group']

	if 'type' in sdef['scene']:
		if not newscene:
			print("Can't change the group of an existing scene")
			errors= True
		else:
			d['type']= sdef['scene']['type']

	if 'transitiontime' in sdef['scene']:
		d['transitiontime']= sdef['scene'].getint('transitiontime')

	if 'appdata' in sdef:
		d['appdata']= {}
		n= 0
		if 'version' in sdef['appdata']:
			d['version']= sdef['appdata'].getint('version')
			n+= 1
		if 'data' in sdef['appdata']:
			d['data']= sdef['appdata']['data']
			n+= 1

		if n == 1:
			print('Both version and data required for appdata')
			errors= True

	if errors:
		exit(1)

	lightstates= dict()
	lightids= list()
	for sec in sdef.keys():
		if sec == 'scene':
			continue
		elif sec == 'appdata':
			if 'json' in sdef[sec]:
				d['appdata']= json.loads(sdef[sec]['json'])
		elif sec.startswith('light '):
			lightid= (sec.split(' '))[1]
			lightids.append(lightid)
			ls= dict()
			for k in sdef[sec].keys():
				if k == 'bri':
					v= round(map_range(sdef[sec].getfloat(k), (0,1), HueColor.range_bri))
				elif k == 'ct':
					v= sdef[sec].getint(k)
				elif k in ('x', 'y'):
					v= sdef[sec].getfloat(k)
					if 'xy' not in ls:
						ls['xy']= list()
					if k == 'x':
						ls['xy'].insert(0,v)
					else:
						ls['xy'].append(v)
					continue
				elif k == 'color':
					try:
						h, s, b= colorwheel.colordef(v)
					except ValueError as e:
						print(str(e))
						exit(1)
					ls['hue']= round(map_range(h, (0,360), HueColorHSB.range_hue))
					ls['sat']= round(map_range(s, (0,1), HueColorHSB.range_sat))
					ls['bri']= round(map_range(s, (0,1), HueColor.range_bri))
					continue
				elif k == 'hue':
					v= round(map_range(sdef[sec].getfloat(k), (0,360), HueColorHSB.range_hue))
				elif k == 'sat':
					v= round(map_range(sdef[sec].getfloat(k), (0,1), HueColorHSB.range_sat))
				elif k == 'on':
					v= sdef[sec].getboolean(k)
				else:
					v= sdef[sec][k]
				ls[k]= v

			if len(ls):
				if 'xy' in ls:
					if len(ls['xy']) != 2:
						print(f'Incomplete xy color for light {lightid}')
						exit(1)
				lightstates[lightid]= ls

	if len(lightstates):
		d['lightstates']= lightstates
	if len(lightids):
		d['lights']= lightids

	scene= HueScene.parse_definition(d, bridge=hue, sceneid=sceneid)
	scene.save()

def do_scene_rename(args):
	hue= init_hue(args)

	scene= hue.get_scene(args.id)
	scene.rename(args.name)

def do_scene_del(args):
	hue= init_hue(args)

	for sceneid in args.id:
		try:
			hue.delete_scene(sceneid)
			print(f'Scene {sceneid} deleted')
		except Exception as e:
			print(e)

def do_scene_play(args):
	hue= init_hue(args)

	for sceneid in args.id:
		try:
			hue.recall_scene(sceneid)
			print(f'Playing scene {sceneid}')
		except Exception as e:
			print(e)

#----------------------------------------------------------------------------
# Schedules
#----------------------------------------------------------------------------

def do_schedule(args):
	hue= init_hue(args)

	scheds= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_schedules(raw=True))
			return

		scheds= hue.get_all_schedules()

	else:
		for schedid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_schedule(schedid, raw=True))
			else:
				sched= hue.get_schedule(schedid)
				scheds[schedid]= sched

		if args.raw:
			return

	for sched in scheds.values():
		print(sched)
		target= sched.command.target()
		print("    "+str(target))
		if isinstance(target, HueGroup):
			if 'scene' in sched.command.body:
				scene= hue.get_scene(sched.command.body['scene'])
				print("        "+str(scene))
		print()


#----------------------------------------------------------------------------
# Sensors
#----------------------------------------------------------------------------

def do_sensor(args):
	hue= init_hue(args)

	sensors= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_sensors(raw=True))
			return

		sensors= hue.get_all_sensors()

	else:
		for sensorid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_sensor(sensorid, raw=True))
			else:
				sensor= hue.get_sensor(sensorid)
				sensors[sensorid]= sensor

		if args.raw:
			return

	for sensor in sensors.values():
		print(sensor)

#----------------------------------------------------------------------------
# Resourcelinks
#----------------------------------------------------------------------------

def do_rlinks_get(args):
	hue= init_hue(args)

	rlinks= dict()

	if not len(args.id):
		if args.raw or args.pretty:
			raw_print(args, hue.get_all_resourcelinks(raw=True))
			return

		rlinks= hue.get_all_resourcelinks()

	else:
		for rlinkid in args.id:
			if args.raw or args.pretty:
				raw_print(args, hue.get_resourcelink(rlinkid, raw=True))
			else:
				rlink= hue.get_resourcelink(rlinkid)
				rlinks[rlinkid]= rlink

		if args.raw:
			return

	for rlink in rlinks.values():
		print(rlink)

#----------------------------------------------------------------------------
# Bridge Configuration
#----------------------------------------------------------------------------

def do_config_get(args):
	hue= init_hue(args)

	if args.all:
		raw_print(args, hue.get_datastore())
	elif args.raw or args.pretty:
		raw_print(args, hue.get_configuration(raw=True))
		return
	

def do_users_get(args):
	hue= init_hue(args)

	userlist= hue.userlist()
	for user in userlist.users():
		print(user)

def do_bridge_def(args):
	config= Config(args.config)

	brid= args.identifier[0]
	bridge= config.get_bridge(brid)
	if bridge is None:
		print(f"No bridge definition matches {brid}")
		exit(1)

	config.set_default_bridge(bridge['serial_number'])
	config.save()

def do_bridge_reg(args):
	hue= None
	config= Config(args.config)

	user_id= None
	serial= None
	
	addr= args.address[0]
	if args.serial_number is not None:
		serial= args.serial_number

	if args.user_id is None:
		print(f'Registering a new user on bridge at {addr}.')

		if not args.button_pressed:
			input('Press the link button on the and hit <ENTER> to continue')

		hue= HueBridge(addr)
		try:
			user_id= hue.create_user()
		except Exception as e:
			print(e)
			print('User registration failed')
			exit(1)

		hue.set_user_id(user_id)
		hue.get_configuration()

		serial= hue.serial_number()
	else:
		user_id= args.user_id[0]

	if serial is None:
		hue= HueBridge(addr, user_id=user_id)
		serial= hue.serial_number()

	kwargs={
		'userid': user_id,
		'addr': addr,
		'serial': serial,
		'overwrite': True
	}

	if args.name is not None:
		# If the new name is rejected, print a warning but still
		# add our bridge definition to the config file (minus the
		# illegal name).

		try:
			hue.rename(args.name)
			kwargs['name']= args.name
		except Exception as e:
			print(e)

	elif hue is not None:
		kwargs['name']= hue.name()

	if config.add_bridge(**kwargs):
		config.save()

#----------------------------------------------------------------------------
# Initialize API
#----------------------------------------------------------------------------

def init_hue(args):
	config= Config(args.config)

	bridge= config.get_bridge(args.bridge)
	if bridge is None:
		if args.bridge is None:
			print('No bridge specified')
		else:
			print('Bridge not found')
		exit(1)

	serial= bridge['serial_number']

	retry= True
	if 'addr' in bridge:
		addr= bridge['addr']
	else:
		print(f'Searching for bridge {serial}')
		addr= _quick_search(serial)
		if addr is None:
			print_wrap(f"Can't find bridge {serial}. Is your bridge powered on and on your network?")
			exit(1)
		print(f'Found bridge {serial} at {addr}')
		config.update(serial, addr=addr)
		retry= False

	if 'user_id' in bridge:
		user_id= bridge['user_id']
	else:
		print_wrap(f'No user registered for bridge {serial}. Use the bridge-regiser command to set up a user id.')
		exit(1)

	# Try to talk to the bridge using the stored IP address. If that
	# doesn't work, do a quick search to see if it's moved.

	try:
		hue= HueBridge(addr, user_id=user_id)
		return hue
	except:
		pass

	if retry:
		print_wrap(f"Can't find bridge {serial} at last known address {addr}. Performing a quick search.")

		addr= _quick_search(serial)
		if addr is None:
			print_wrap(f"Can't find bridge {serial}. Is your bridge powered on and on your network?")
			exit(1)

		print(f'Found bridge {serial} at {addr}')
		config.update(serial, addr=addr)

		try:
			hue= HueBridge(addr, user_id=user_id)
			return hue
		except Exception as e:
			print(str(e))
	
	print(f'Unable to connect to your bridge {serial} at {addr}')

	exit(1)

def _quick_search(serial):
	bridges= HueBridgeSearch.quick_search()
	if serial in bridges:
		return bridges[serial]['ipAddress']

	return None

#----------------------------------------
# Color conversion
#----------------------------------------

def do_color_name(args):
	if args.all:
		fidx= 0
		for fam in colorwheel.colorfamilies():
			cidx= 0
			for color in colorwheel.colorfamily(fam):
				h, s, b= colorwheel.colordef_byindex(fidx, cidx)
				print(f'{color}: {h},{s},{b}')
				cidx+= 1
			fidx+= 1
	elif args.families:
		for fam in colorwheel.colorfamilies():
			print('{:s}: {:s}'.format(fam, ', '.join(colorwheel.colorfamily(fam))))
	else:
		for name in args.name:
			try:
				h, s, b= colorwheel.colordef(name)
				print(f'{name}: {h},{s},{b}')
			except ValueError:
				print(f'{name}: unknown color')

def do_color(args):
	c= None

	if args.from_color == args.to_color:
		exit(0)

	if args.from_color != 'ct':
		if args.from_color == 'rgb' and ',' not in args.color:
			# Is it a hex color?
			try:
				c= hex_to_rgb(args.from_color)
			except:
				print('Color must be hex code or comma-separated triplet')
				exit(1)
		else:
			c= list(map(lambda x: float(x), args.color.split(',')))
			if len(c) != 3:
				print('Color must be comma-separated triplet')
				exit(1)

	if args.from_color == 'xyY':
		c[2]= map_range(c[2], (0,1), HueColorHSB.range_bri)
		color= HueColorxyY(*c)
	elif args.from_color == 'hsb':
		# Need to convert to bridge units
		c[0]= map_range(c[0], (0,360), HueColorHSB.range_hue)
		c[1]= map_range(c[1], (0,1), HueColorHSB.range_sat)
		c[2]= map_range(c[2], (0,1), HueColor.range_bri)
		color= HueColorHSB(*c)
	elif args.from_color == 'rgb':
		hsb= list(rgb_to_hsb(list(map(lambda x: x/255, c))))
		# Need to convert to bridge units
		hsb[0]= map_range(hsb[0], (0,360), HueColorHSB.range_hue)
		hsb[1]= map_range(hsb[1], (0,1), HueColorHSB.range_sat)
		hsb[2]= map_range(hsb[2], (0,1), HueColor.range_bri)
		color= HueColorHSB(*hsb)
		if args.to_color == 'hsb':
			print(color)
			exit(0)
	elif args.from_color == 'ct':
		color= HueColorTemp(float(args.color), kelvin=True)

	if args.to_color == 'xyY':
		xyY= color.xyY()
		newcolor= HueColorxyY(*xyY)
		print("x={:.4f} y={:.4f} Y={:.4f}".format(newcolor.x(),
			newcolor.y(), newcolor.brightness()))
	elif args.to_color == 'hsb':
		hsb= color.hsb()
		newcolor= HueColorHSB(*hsb)
		print('hue={:.4f} sat={:.4f} bri={:.4f}'.format(
			newcolor.hue(torange=(0,360)),
			newcolor.sat(torange=(0,1)),
			newcolor.brightness(torange=(0,1)))
		)
	elif args.to_color == 'rgb':
		r, g, b= list(map(lambda x: int(x*255), color.rgb()))
		print(f'{r},{g},{b} #{r:02x}{b:02x}{g:02x}')


#----------------------------------------
# Util functions
#----------------------------------------

def print_wrap(s):
	print("\n".join(textwrap.wrap(s)))

# Raw print and pretty-print

def raw_print(args, s):
	if args.pretty:
		print(json.dumps(json.loads(s), indent=4))
	else:
		print(s)

# Arguments that are common to a lot of commands

def standard_args(parser, *arglist):
	if 'bridge' in arglist:
		parser.add_argument('-b', '--bridge',
			help='Bridge to use. Can specify a serial number, friendly name, or address')

	if 'raw' in arglist or 'pretty' in arglist:
		group_raw= parser.add_mutually_exclusive_group()
		if 'raw' in arglist:
			group_raw.add_argument('-r', '--raw', action='store_true',
				help='Print raw response')
	
		if 'pretty' in arglist:
			group_raw.add_argument('-R', '--pretty', action='store_true',
				help='Pretty-print raw response')


#===========================================================================
# Main program starts here
#===========================================================================

#----------------------------------------
# Command-line arguments
#----------------------------------------

parser= ArgumentParser()
parser.add_argument('-c', '--config', help='Use configuration file CONFIG',
	nargs=1)	

# Create subcommands

subparsers= parser.add_subparsers()

# Bridge definitions/config file management 
#--------------------

# bridge-search

parser_search= subparsers.add_parser('bridge-search',
	help='Search for a Philips Hue bridge on local networks')
parser_search.add_argument('-S', '--search-time', type=int,
	help='The time to spend searching for Hue Bridges in seconds. Does not apply to --quick searches.')
parser_search.add_argument('-q', '--quick', action='store_true',
	help='Perform a quick search for bridges by querying the MeetHue portal. This will not find new/unconfigured bridges, or bridges that do not have internet access.')
parser_search.set_defaults(func=do_bridge_search)

# bridge-register

parser_bridge_reg= subparsers.add_parser('bridge-register',
	help='Add a bridge definition and register a user ID')
parser_bridge_reg.add_argument('-B', '--button-pressed', action='store_true',
	help='The link button on the bridge has been pressed.')
parser_bridge_reg.add_argument('-n', '--name', nargs='?',
	help='A friendly name for the bridge')
parser_bridge_reg.add_argument('-u', '--user-id', nargs=1,
	help='The user id for the target bridge. If ommitted, a new user will be registered on the bridge.')
parser_bridge_reg.add_argument('-s', '--serial-number', nargs='?',
	help='The bridge serial number. Required if the bridge is not online.')
parser_bridge_reg.add_argument('address', nargs=1, 
	help='The IP address of the bridge to add')
parser_bridge_reg.set_defaults(func=do_bridge_reg)

# bridge-default

parser_bridge_def= subparsers.add_parser('bridge-default',
	help='Set the default bridge')
parser_bridge_def.add_argument('identifier', type=str, nargs=1,
	help='The bridge to use. Can be a name, IP address, or serial number. The bridge must already be defined in your .huemgr config file.')
parser_bridge_def.set_defaults(func=do_bridge_def)

# Group management
#--------------------

# list

parser_group= subparsers.add_parser('group',
	help='List group definitions')
standard_args(parser_group, 'raw', 'pretty', 'bridge')
parser_group.add_argument('-s', '--sort', choices=['name','id','type'],
	help='Sort list by field')
parser_group.add_argument('id', nargs='*', help='Group IDs')
parser_group.set_defaults(func=do_group)

# add

parser_group_add= subparsers.add_parser('group-add',
	help='Rename a group')
standard_args(parser_group_add, 'bridge')
parser_group_add.add_argument('-c', '--room-class', 
	help='Room class. Only valid when --type is set to Room. For a list of supported classes, run "huemgr room-classes". Default room class is Other.')
parser_group_add.add_argument('-t', '--type', 
	choices=HueGroupType.usertypes(), help=f'Group type. Default is a {HueGroupType.LightGroup}.')
parser_group_add.add_argument('name', nargs=1, help='New group name')
parser_group_add.add_argument('lightid', nargs='+',
	help="Light IDs to add to the group")
parser_group_add.set_defaults(func=do_group_add)

# delete

parser_group_del= subparsers.add_parser('group-delete',
	help='Delete a group')
standard_args(parser_group_del, 'bridge')
parser_group_del.add_argument('id', nargs='+',
	help='Group ID(s) of the group(s) to delete')
parser_group_del.set_defaults(func=do_group_del)

# rename

parser_group_rename= subparsers.add_parser('group-rename',
	help='Rename a group')
standard_args(parser_group_rename, 'bridge')
parser_group_rename.add_argument('id', help='Group ID')
parser_group_rename.add_argument('name', help='New group name')
parser_group_rename.set_defaults(func=do_group_rename)

# light memembership mgmt

parser_group_edit= subparsers.add_parser('group-lights',
	help="Set/change a group's member lights")
standard_args(parser_group_edit, 'bridge')
parser_group_edit.add_argument('-g', '--groupid', 
	required=True, help='The group to modify')
parser_group_edit.add_argument('-a', '--add-lights', nargs='+',
	metavar='LIGHTID', help='Add lights to the group')
parser_group_edit.add_argument('-r', '--remove-lights', nargs='+',
	metavar='LIGHTID', help='Remove lights from the group')
parser_group_edit.add_argument('-s', '--set-lights', nargs='+',
	metavar='LIGHTID', help='Set the list of lights in the group. Cannot be combined with -a or -r.')
parser_group_edit.set_defaults(func=do_group_edit)

# Light management
#--------------------

# light listing

parser_light= subparsers.add_parser('light',
	help='List light definitions')
standard_args(parser_light, 'raw', 'pretty', 'bridge')
parser_light.add_argument('-s', '--sort', choices=['name','id'],
	help='Sort list by field')
group_ex= parser_light.add_mutually_exclusive_group()
group_ex.add_argument('-O', '--on', action='store_true',
	help='Only show lights that are on')
group_ex.add_argument('-X', '--off', action='store_true',
	help='Only show lights that are off')
parser_light.add_argument('id', nargs='*', help='Light IDs')
parser_light.set_defaults(func=do_light)

# search for new lights

parser_light_add= subparsers.add_parser('light-add',
	help='Search for new lights and add them to the bridge')
standard_args(parser_light_add, 'bridge')
parser_light_add.add_argument('-X', '--no-scan', action='store_true',
	help='Just report the light(s) found during hte last search without starting a new one')
parser_light_add.add_argument('serial', nargs='*',
	help='Optional list of serial numbers to add (maximum of 10)')
parser_light_add.set_defaults(func=do_light_add)

# light on/off

parser_light_pwr= subparsers.add_parser('light-power',
	help='Turn lights on (default) or off')
standard_args(parser_light_pwr, 'bridge')
parser_light_pwr.add_argument('-a', '--all', action='store_true',
	help='Control all lights on the bridge.')
parser_light_pwr.add_argument('-t', '--transition-time', type=float,
	help='Set transition time in seconds. This can be fractional, but the minimum granularity is 1/10th of a second, so .1 seconds (100 ms). Note that the transition time only applies when turning lights off.')
group_ex= parser_light_pwr.add_mutually_exclusive_group()
group_ex.add_argument('-B', '--brightness', nargs='?', type=float, 
	help='Turn lights on to the given brightness level.')
group_ex.add_argument('-X', '--off', action='store_true',
	help='Turn lights off instead of on')
parser_light_pwr.add_argument('id', nargs='*', help='Light IDs')
parser_light_pwr.set_defaults(func=do_light_power)

# light rename

parser_light_rename= subparsers.add_parser('light-rename', 
	help='Rename a light')
standard_args(parser_light_rename, 'bridge')
parser_light_rename.add_argument('id', help='Light ID')
parser_light_rename.add_argument('name', help='New light name')
parser_light_rename.set_defaults(func=do_light_rename)

# set light state

parser_light_set= subparsers.add_parser('light-set',
	help='Set light attributes')
standard_args(parser_light_set, 'bridge')
parser_light_set.add_argument('-a', '--all', action='store_true',
	help='Set all lights on the bridge')

parser_light_set.add_argument('-n', '--color-name', type=str,
	help='Set a light to a known, named color')

parser_light_set.add_argument('-c', '--color-temperature', type=str,
	help='Set a light color temperature in Kelvin, or specify a +/- increment.')
parser_light_set.add_argument('--xy', type=str,
	help='Set xy color coordinates as a comma-separated pair, or specify a +/- increment. Cannot be combined with other color modes.')
parser_light_set.add_argument('-H', '--hue', type=str,
	help='Set a color hue from 0 to 360, or specify a +/- increment. Hue can be fractional. Cannot be combined with other color modes.')
parser_light_set.add_argument('-S', '--saturation', type=str,
	help='Set a color saturation from 0 to 1, or specify a +/- increment. Cannot be combined with other color modes.')

parser_light_set.add_argument('-B', '--brightness', type=str,
	help='Set a brightness from 0 to 1, or specify a +/- increment.')

parser_light_set.add_argument('-A', '--alert', choices=(HueAlertEffect.NoAlert,
		HueAlertEffect.Select, HueAlertEffect.LSelect),
	help='Set an alert effect')
parser_light_set.add_argument('-e', '--dynamic-effect',
	choices=(HueDynamicEffect.NoEffect, HueDynamicEffect.ColorLoop),
	help='Set a dynamic effect')

parser_light_set.add_argument('-t', '--transition-time', type=float,
	help='Set transition time in seconds. This can be fractional, but the minimum granularity is 1/10th of a second, so .1 seconds (100 ms).')

parser_light_set.add_argument('id', nargs='*', help='Light IDs')
parser_light_set.set_defaults(func=do_light_set)

# Rule management
#--------------------

# rule

parser_rule= subparsers.add_parser('rule',
	help='List rule definitions')
standard_args(parser_rule, 'raw', 'pretty', 'bridge')
parser_rule.add_argument('id', nargs='*', help='Scene IDs')
parser_rule.set_defaults(func=do_rule)

# Scene management
#--------------------

# scene

parser_scene= subparsers.add_parser('scene',
	help='List scene definitions')
standard_args(parser_scene, 'raw', 'pretty', 'bridge')
parser_scene.add_argument('-i', '--ignore-autogenerated', action='store_true',
	help="""Filter out the Hue app's auto-generated scenes from the scene list. These include the "standard" Hue app scenes ("""+', '.join(HueAppStandardScenes)+""") that it auto-creates for each room, as well as the "Last on state" scenes used by dimmer switches. This may accidentally filter out scenes created by the user if they use a name that matches one of the standard scenes.""")
parser_scene.add_argument('-x', '--no-light-states', action='store_true',
	help="Don't display light states")
parser_scene.add_argument('-S', '--summary', action='store_true',
	help='Only print a brief scene summary')
parser_scene.add_argument('-s', '--sort', choices=['name','id','lastupdated'],
	help='Sort list by field')
parser_scene.add_argument('id', nargs='*', help='Scene IDs')
parser_scene.set_defaults(func=do_scene)

# scene-play

parser_scene_play= subparsers.add_parser('scene-play',
	help='Play a scene')
standard_args(parser_scene_play, 'bridge')
parser_scene_play.add_argument('id', nargs='+', help='Scene IDs')
parser_scene_play.set_defaults(func=do_scene_play)

# scene-rename

parser_scene_rename= subparsers.add_parser('scene-rename', 
	help='Rename a scene')
standard_args(parser_scene_rename, 'bridge')
parser_scene_rename.add_argument('id', help='Light ID')
parser_scene_rename.add_argument('name', help='New scene name')
parser_scene_rename.set_defaults(func=do_scene_rename)

# scene-delete

parser_scene_del= subparsers.add_parser('scene-delete',
	help='Delete a scene')
standard_args(parser_scene_del, 'bridge')
parser_scene_del.add_argument('id', nargs='+', help='Scene IDs')
parser_scene_del.set_defaults(func=do_scene_del)

# scene-dump

parser_scene_dump= subparsers.add_parser('scene-dump',
	help='Dump a scene definition to INI format')
standard_args(parser_scene_dump, 'bridge')
parser_scene_dump.add_argument('-f', '--file', 
	help='Write the scene definition to FILE')
parser_scene_dump.add_argument('id', help='Scene ID')
parser_scene_dump.set_defaults(func=do_scene_dump)

# scene-load

parser_scene_load= subparsers.add_parser('scene-load',
	help='Load a scene definition from an INI file and save it to the bridge. A new scene will be created unless an existing scene id is specified.')
standard_args(parser_scene_load, 'bridge')
parser_scene_load.add_argument('-s', '--scene-id', 
	help='Update scene with scene id SCENE_ID. This will override any scene id stored in the INI file.')
parser_scene_load.add_argument('file', 
	help='The INI file containing the scene definition')
parser_scene_load.set_defaults(func=do_scene_load)

# Schedule management
#--------------------

# schedule

parser_sched= subparsers.add_parser('schedule',
	help='List schedule definitions')
standard_args(parser_sched, 'raw', 'pretty', 'bridge')
parser_sched.add_argument('id', nargs='*', help='Schedule IDs')
parser_sched.set_defaults(func=do_schedule)

# Sensor management
#--------------------

parser_sensor= subparsers.add_parser('sensor',
	help='List sensor definitions')
standard_args(parser_sensor, 'raw', 'pretty', 'bridge')
parser_sensor.add_argument('id', nargs='*', help='Sensor IDs')
parser_sensor.set_defaults(func=do_sensor)

# Bridge configuration
#--------------------

parser_config_get= subparsers.add_parser('config-get',
	help='Get bridge configuration')
standard_args(parser_config_get, 'raw', 'pretty', 'bridge')
parser_config_get.add_argument('-a', '--all', action='store_true',
	help='Dump the full datastore (implies --raw).')
parser_config_get.set_defaults(func=do_config_get)

# Bridge whitelist management
#--------------------

parser_userlist_get= subparsers.add_parser('user-get',
	help='Get authorized userlist')
standard_args(parser_userlist_get, 'bridge')
parser_userlist_get.set_defaults(func=do_users_get)

# Resourcelinks
#----------------------------------------

parser_rlink_get= subparsers.add_parser('rlinks',
	help='Get resourcelinks')
standard_args(parser_rlink_get, 'raw', 'pretty', 'bridge')
parser_rlink_get.add_argument('id', nargs='*', help='Resourcelink IDs')
parser_rlink_get.set_defaults(func=do_rlinks_get)


# Color names
#----------------------------------------
parser_color_name= subparsers.add_parser('color-name', 
	help='Obtain color values for known color names')
parser_color_name.add_argument('-a', '--all', action='store_true',
	help='Get all known colors')
parser_color_name.add_argument('-f', '--families', action='store_true',
	help='List color families')
parser_color_name.add_argument('name', nargs='*', 
	help='Color name[s]')
parser_color_name.set_defaults(func=do_color_name)

# Color conversion
#----------------------------------------

parser_color= subparsers.add_parser('color', 
	help='Convert colors between Hue-supported color systems')
parser_color.add_argument('-f', '--from-color', choices=['xyY','hsb','rgb','ct'],
	required=True, help='System to convert from')
parser_color.add_argument('-t', '--to-color', choices=['xyY','hsb','rgb'],
	required=True, help='System to convert to')
parser_color.add_argument('color', help='A color coordinate as comma-separated values. xyY are from 0 to 1, h is from 0 to 360, sat and bri are from 0 to 1, rgb are from 0 to 255, and ct is a color temperature in Kelvin.')
parser_color.set_defaults(func=do_color)

# Misc
#----------------------------------------

parser_room_classes= subparsers.add_parser('room-classes',
	help='List supported room classes')
parser_room_classes.set_defaults(func=do_room_classes)

#----------------------------------------
# Parse and go
#----------------------------------------

args= parser.parse_args()

if 'func' in args:
	args.func(args)


